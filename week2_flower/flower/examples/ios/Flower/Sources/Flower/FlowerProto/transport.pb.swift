// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: transport.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Adap GmbH. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Flower_Transport_Reason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case reconnect // = 1
  case powerDisconnected // = 2
  case wifiUnavailable // = 3
  case ack // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .reconnect
    case 2: self = .powerDisconnected
    case 3: self = .wifiUnavailable
    case 4: self = .ack
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .reconnect: return 1
    case .powerDisconnected: return 2
    case .wifiUnavailable: return 3
    case .ack: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Flower_Transport_Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Flower_Transport_Reason] = [
    .unknown,
    .reconnect,
    .powerDisconnected,
    .wifiUnavailable,
    .ack,
  ]
}

#endif  // swift(>=4.2)

struct Flower_Transport_Parameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tensors: [Data] = []

  var tensorType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Flower_Transport_ServerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Flower_Transport_ServerMessage.OneOf_Msg? = nil

  var reconnect: Flower_Transport_ServerMessage.Reconnect {
    get {
      if case .reconnect(let v)? = msg {return v}
      return Flower_Transport_ServerMessage.Reconnect()
    }
    set {msg = .reconnect(newValue)}
  }

  var getParameters: Flower_Transport_ServerMessage.GetParameters {
    get {
      if case .getParameters(let v)? = msg {return v}
      return Flower_Transport_ServerMessage.GetParameters()
    }
    set {msg = .getParameters(newValue)}
  }

  var fitIns: Flower_Transport_ServerMessage.FitIns {
    get {
      if case .fitIns(let v)? = msg {return v}
      return Flower_Transport_ServerMessage.FitIns()
    }
    set {msg = .fitIns(newValue)}
  }

  var evaluateIns: Flower_Transport_ServerMessage.EvaluateIns {
    get {
      if case .evaluateIns(let v)? = msg {return v}
      return Flower_Transport_ServerMessage.EvaluateIns()
    }
    set {msg = .evaluateIns(newValue)}
  }

  var propertiesIns: Flower_Transport_ServerMessage.PropertiesIns {
    get {
      if case .propertiesIns(let v)? = msg {return v}
      return Flower_Transport_ServerMessage.PropertiesIns()
    }
    set {msg = .propertiesIns(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    case reconnect(Flower_Transport_ServerMessage.Reconnect)
    case getParameters(Flower_Transport_ServerMessage.GetParameters)
    case fitIns(Flower_Transport_ServerMessage.FitIns)
    case evaluateIns(Flower_Transport_ServerMessage.EvaluateIns)
    case propertiesIns(Flower_Transport_ServerMessage.PropertiesIns)

  #if !swift(>=4.1)
    static func ==(lhs: Flower_Transport_ServerMessage.OneOf_Msg, rhs: Flower_Transport_ServerMessage.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.reconnect, .reconnect): return {
        guard case .reconnect(let l) = lhs, case .reconnect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getParameters, .getParameters): return {
        guard case .getParameters(let l) = lhs, case .getParameters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fitIns, .fitIns): return {
        guard case .fitIns(let l) = lhs, case .fitIns(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.evaluateIns, .evaluateIns): return {
        guard case .evaluateIns(let l) = lhs, case .evaluateIns(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.propertiesIns, .propertiesIns): return {
        guard case .propertiesIns(let l) = lhs, case .propertiesIns(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Reconnect {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var seconds: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GetParameters {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct FitIns {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parameters: Flower_Transport_Parameters {
      get {return _parameters ?? Flower_Transport_Parameters()}
      set {_parameters = newValue}
    }
    /// Returns true if `parameters` has been explicitly set.
    var hasParameters: Bool {return self._parameters != nil}
    /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
    mutating func clearParameters() {self._parameters = nil}

    var config: Dictionary<String,Flower_Transport_Scalar> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parameters: Flower_Transport_Parameters? = nil
  }

  struct EvaluateIns {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parameters: Flower_Transport_Parameters {
      get {return _parameters ?? Flower_Transport_Parameters()}
      set {_parameters = newValue}
    }
    /// Returns true if `parameters` has been explicitly set.
    var hasParameters: Bool {return self._parameters != nil}
    /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
    mutating func clearParameters() {self._parameters = nil}

    var config: Dictionary<String,Flower_Transport_Scalar> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parameters: Flower_Transport_Parameters? = nil
  }

  struct PropertiesIns {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var config: Dictionary<String,Flower_Transport_Scalar> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Flower_Transport_ClientMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Flower_Transport_ClientMessage.OneOf_Msg? = nil

  var disconnect: Flower_Transport_ClientMessage.Disconnect {
    get {
      if case .disconnect(let v)? = msg {return v}
      return Flower_Transport_ClientMessage.Disconnect()
    }
    set {msg = .disconnect(newValue)}
  }

  var parametersRes: Flower_Transport_ClientMessage.ParametersRes {
    get {
      if case .parametersRes(let v)? = msg {return v}
      return Flower_Transport_ClientMessage.ParametersRes()
    }
    set {msg = .parametersRes(newValue)}
  }

  var fitRes: Flower_Transport_ClientMessage.FitRes {
    get {
      if case .fitRes(let v)? = msg {return v}
      return Flower_Transport_ClientMessage.FitRes()
    }
    set {msg = .fitRes(newValue)}
  }

  var evaluateRes: Flower_Transport_ClientMessage.EvaluateRes {
    get {
      if case .evaluateRes(let v)? = msg {return v}
      return Flower_Transport_ClientMessage.EvaluateRes()
    }
    set {msg = .evaluateRes(newValue)}
  }

  var propertiesRes: Flower_Transport_ClientMessage.PropertiesRes {
    get {
      if case .propertiesRes(let v)? = msg {return v}
      return Flower_Transport_ClientMessage.PropertiesRes()
    }
    set {msg = .propertiesRes(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable {
    case disconnect(Flower_Transport_ClientMessage.Disconnect)
    case parametersRes(Flower_Transport_ClientMessage.ParametersRes)
    case fitRes(Flower_Transport_ClientMessage.FitRes)
    case evaluateRes(Flower_Transport_ClientMessage.EvaluateRes)
    case propertiesRes(Flower_Transport_ClientMessage.PropertiesRes)

  #if !swift(>=4.1)
    static func ==(lhs: Flower_Transport_ClientMessage.OneOf_Msg, rhs: Flower_Transport_ClientMessage.OneOf_Msg) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.disconnect, .disconnect): return {
        guard case .disconnect(let l) = lhs, case .disconnect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.parametersRes, .parametersRes): return {
        guard case .parametersRes(let l) = lhs, case .parametersRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fitRes, .fitRes): return {
        guard case .fitRes(let l) = lhs, case .fitRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.evaluateRes, .evaluateRes): return {
        guard case .evaluateRes(let l) = lhs, case .evaluateRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.propertiesRes, .propertiesRes): return {
        guard case .propertiesRes(let l) = lhs, case .propertiesRes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct Disconnect {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var reason: Flower_Transport_Reason = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ParametersRes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parameters: Flower_Transport_Parameters {
      get {return _parameters ?? Flower_Transport_Parameters()}
      set {_parameters = newValue}
    }
    /// Returns true if `parameters` has been explicitly set.
    var hasParameters: Bool {return self._parameters != nil}
    /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
    mutating func clearParameters() {self._parameters = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parameters: Flower_Transport_Parameters? = nil
  }

  struct FitRes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var parameters: Flower_Transport_Parameters {
      get {return _parameters ?? Flower_Transport_Parameters()}
      set {_parameters = newValue}
    }
    /// Returns true if `parameters` has been explicitly set.
    var hasParameters: Bool {return self._parameters != nil}
    /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
    mutating func clearParameters() {self._parameters = nil}

    var numExamples: Int64 = 0

    var numExamplesCeil: Int64 = 0

    var fitDuration: Float = 0

    var metrics: Dictionary<String,Flower_Transport_Scalar> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _parameters: Flower_Transport_Parameters? = nil
  }

  struct EvaluateRes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var numExamples: Int64 = 0

    var loss: Float = 0

    var accuracy: Float = 0

    var metrics: Dictionary<String,Flower_Transport_Scalar> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct PropertiesRes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var properties: Dictionary<String,Flower_Transport_Scalar> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Flower_Transport_Scalar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The following oneof contains all types that ProtoBuf considers to be
  /// "Scalar Value Types". Commented-out types are listed for reference and
  /// might be enabled in future releases. Source:
  /// https://developers.google.com/protocol-buffers/docs/proto3#scalar
  var scalar: Flower_Transport_Scalar.OneOf_Scalar? = nil

  var double: Double {
    get {
      if case .double(let v)? = scalar {return v}
      return 0
    }
    set {scalar = .double(newValue)}
  }

  /// float float = 2;
  /// int32 int32 = 3;
  /// int64 int64 = 4;
  /// uint32 uint32 = 5;
  /// uint64 uint64 = 6;
  /// sint32 sint32 = 7;
  var sint64: Int64 {
    get {
      if case .sint64(let v)? = scalar {return v}
      return 0
    }
    set {scalar = .sint64(newValue)}
  }

  /// fixed32 fixed32 = 9;
  /// fixed64 fixed64 = 10;
  /// sfixed32 sfixed32 = 11;
  /// sfixed64 sfixed64 = 12;
  var bool: Bool {
    get {
      if case .bool(let v)? = scalar {return v}
      return false
    }
    set {scalar = .bool(newValue)}
  }

  var string: String {
    get {
      if case .string(let v)? = scalar {return v}
      return String()
    }
    set {scalar = .string(newValue)}
  }

  var bytes: Data {
    get {
      if case .bytes(let v)? = scalar {return v}
      return Data()
    }
    set {scalar = .bytes(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The following oneof contains all types that ProtoBuf considers to be
  /// "Scalar Value Types". Commented-out types are listed for reference and
  /// might be enabled in future releases. Source:
  /// https://developers.google.com/protocol-buffers/docs/proto3#scalar
  enum OneOf_Scalar: Equatable {
    case double(Double)
    /// float float = 2;
    /// int32 int32 = 3;
    /// int64 int64 = 4;
    /// uint32 uint32 = 5;
    /// uint64 uint64 = 6;
    /// sint32 sint32 = 7;
    case sint64(Int64)
    /// fixed32 fixed32 = 9;
    /// fixed64 fixed64 = 10;
    /// sfixed32 sfixed32 = 11;
    /// sfixed64 sfixed64 = 12;
    case bool(Bool)
    case string(String)
    case bytes(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Flower_Transport_Scalar.OneOf_Scalar, rhs: Flower_Transport_Scalar.OneOf_Scalar) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.double, .double): return {
        guard case .double(let l) = lhs, case .double(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sint64, .sint64): return {
        guard case .sint64(let l) = lhs, case .sint64(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bool, .bool): return {
        guard case .bool(let l) = lhs, case .bool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "flower.transport"

extension Flower_Transport_Reason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "RECONNECT"),
    2: .same(proto: "POWER_DISCONNECTED"),
    3: .same(proto: "WIFI_UNAVAILABLE"),
    4: .same(proto: "ACK"),
  ]
}

extension Flower_Transport_Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Parameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tensors"),
    2: .standard(proto: "tensor_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.tensors) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tensorType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tensors.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.tensors, fieldNumber: 1)
    }
    if !self.tensorType.isEmpty {
      try visitor.visitSingularStringField(value: self.tensorType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_Parameters, rhs: Flower_Transport_Parameters) -> Bool {
    if lhs.tensors != rhs.tensors {return false}
    if lhs.tensorType != rhs.tensorType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ServerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reconnect"),
    2: .standard(proto: "get_parameters"),
    3: .standard(proto: "fit_ins"),
    4: .standard(proto: "evaluate_ins"),
    5: .standard(proto: "properties_ins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flower_Transport_ServerMessage.Reconnect?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .reconnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .reconnect(v)
        }
      }()
      case 2: try {
        var v: Flower_Transport_ServerMessage.GetParameters?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .getParameters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .getParameters(v)
        }
      }()
      case 3: try {
        var v: Flower_Transport_ServerMessage.FitIns?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .fitIns(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .fitIns(v)
        }
      }()
      case 4: try {
        var v: Flower_Transport_ServerMessage.EvaluateIns?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .evaluateIns(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .evaluateIns(v)
        }
      }()
      case 5: try {
        var v: Flower_Transport_ServerMessage.PropertiesIns?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .propertiesIns(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .propertiesIns(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .reconnect?: try {
      guard case .reconnect(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getParameters?: try {
      guard case .getParameters(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .fitIns?: try {
      guard case .fitIns(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .evaluateIns?: try {
      guard case .evaluateIns(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .propertiesIns?: try {
      guard case .propertiesIns(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ServerMessage, rhs: Flower_Transport_ServerMessage) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ServerMessage.Reconnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ServerMessage.protoMessageName + ".Reconnect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seconds != 0 {
      try visitor.visitSingularInt64Field(value: self.seconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ServerMessage.Reconnect, rhs: Flower_Transport_ServerMessage.Reconnect) -> Bool {
    if lhs.seconds != rhs.seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ServerMessage.GetParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ServerMessage.protoMessageName + ".GetParameters"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ServerMessage.GetParameters, rhs: Flower_Transport_ServerMessage.GetParameters) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ServerMessage.FitIns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ServerMessage.protoMessageName + ".FitIns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: &self.config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.config.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: self.config, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ServerMessage.FitIns, rhs: Flower_Transport_ServerMessage.FitIns) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ServerMessage.EvaluateIns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ServerMessage.protoMessageName + ".EvaluateIns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: &self.config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.config.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: self.config, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ServerMessage.EvaluateIns, rhs: Flower_Transport_ServerMessage.EvaluateIns) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ServerMessage.PropertiesIns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ServerMessage.protoMessageName + ".PropertiesIns"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: &self.config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.config.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: self.config, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ServerMessage.PropertiesIns, rhs: Flower_Transport_ServerMessage.PropertiesIns) -> Bool {
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ClientMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disconnect"),
    2: .standard(proto: "parameters_res"),
    3: .standard(proto: "fit_res"),
    4: .standard(proto: "evaluate_res"),
    5: .standard(proto: "properties_res"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Flower_Transport_ClientMessage.Disconnect?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .disconnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .disconnect(v)
        }
      }()
      case 2: try {
        var v: Flower_Transport_ClientMessage.ParametersRes?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .parametersRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .parametersRes(v)
        }
      }()
      case 3: try {
        var v: Flower_Transport_ClientMessage.FitRes?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .fitRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .fitRes(v)
        }
      }()
      case 4: try {
        var v: Flower_Transport_ClientMessage.EvaluateRes?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .evaluateRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .evaluateRes(v)
        }
      }()
      case 5: try {
        var v: Flower_Transport_ClientMessage.PropertiesRes?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .propertiesRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .propertiesRes(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .parametersRes?: try {
      guard case .parametersRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .fitRes?: try {
      guard case .fitRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .evaluateRes?: try {
      guard case .evaluateRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .propertiesRes?: try {
      guard case .propertiesRes(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ClientMessage, rhs: Flower_Transport_ClientMessage) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ClientMessage.Disconnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ClientMessage.protoMessageName + ".Disconnect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ClientMessage.Disconnect, rhs: Flower_Transport_ClientMessage.Disconnect) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ClientMessage.ParametersRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ClientMessage.protoMessageName + ".ParametersRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ClientMessage.ParametersRes, rhs: Flower_Transport_ClientMessage.ParametersRes) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ClientMessage.FitRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ClientMessage.protoMessageName + ".FitRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .standard(proto: "num_examples"),
    3: .standard(proto: "num_examples_ceil"),
    4: .standard(proto: "fit_duration"),
    5: .same(proto: "metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.numExamples) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.numExamplesCeil) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.fitDuration) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: &self.metrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.numExamples != 0 {
      try visitor.visitSingularInt64Field(value: self.numExamples, fieldNumber: 2)
    }
    if self.numExamplesCeil != 0 {
      try visitor.visitSingularInt64Field(value: self.numExamplesCeil, fieldNumber: 3)
    }
    if self.fitDuration != 0 {
      try visitor.visitSingularFloatField(value: self.fitDuration, fieldNumber: 4)
    }
    if !self.metrics.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: self.metrics, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ClientMessage.FitRes, rhs: Flower_Transport_ClientMessage.FitRes) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs.numExamples != rhs.numExamples {return false}
    if lhs.numExamplesCeil != rhs.numExamplesCeil {return false}
    if lhs.fitDuration != rhs.fitDuration {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ClientMessage.EvaluateRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ClientMessage.protoMessageName + ".EvaluateRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_examples"),
    2: .same(proto: "loss"),
    3: .same(proto: "accuracy"),
    4: .same(proto: "metrics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.numExamples) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.loss) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.accuracy) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: &self.metrics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numExamples != 0 {
      try visitor.visitSingularInt64Field(value: self.numExamples, fieldNumber: 1)
    }
    if self.loss != 0 {
      try visitor.visitSingularFloatField(value: self.loss, fieldNumber: 2)
    }
    if self.accuracy != 0 {
      try visitor.visitSingularFloatField(value: self.accuracy, fieldNumber: 3)
    }
    if !self.metrics.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: self.metrics, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ClientMessage.EvaluateRes, rhs: Flower_Transport_ClientMessage.EvaluateRes) -> Bool {
    if lhs.numExamples != rhs.numExamples {return false}
    if lhs.loss != rhs.loss {return false}
    if lhs.accuracy != rhs.accuracy {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_ClientMessage.PropertiesRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Flower_Transport_ClientMessage.protoMessageName + ".PropertiesRes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: &self.properties) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Flower_Transport_Scalar>.self, value: self.properties, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_ClientMessage.PropertiesRes, rhs: Flower_Transport_ClientMessage.PropertiesRes) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Flower_Transport_Scalar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Scalar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "double"),
    8: .same(proto: "sint64"),
    13: .same(proto: "bool"),
    14: .same(proto: "string"),
    15: .same(proto: "bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.scalar != nil {try decoder.handleConflictingOneOf()}
          self.scalar = .double(v)
        }
      }()
      case 8: try {
        var v: Int64?
        try decoder.decodeSingularSInt64Field(value: &v)
        if let v = v {
          if self.scalar != nil {try decoder.handleConflictingOneOf()}
          self.scalar = .sint64(v)
        }
      }()
      case 13: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.scalar != nil {try decoder.handleConflictingOneOf()}
          self.scalar = .bool(v)
        }
      }()
      case 14: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.scalar != nil {try decoder.handleConflictingOneOf()}
          self.scalar = .string(v)
        }
      }()
      case 15: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.scalar != nil {try decoder.handleConflictingOneOf()}
          self.scalar = .bytes(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.scalar {
    case .double?: try {
      guard case .double(let v)? = self.scalar else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    }()
    case .sint64?: try {
      guard case .sint64(let v)? = self.scalar else { preconditionFailure() }
      try visitor.visitSingularSInt64Field(value: v, fieldNumber: 8)
    }()
    case .bool?: try {
      guard case .bool(let v)? = self.scalar else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    }()
    case .string?: try {
      guard case .string(let v)? = self.scalar else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.scalar else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Flower_Transport_Scalar, rhs: Flower_Transport_Scalar) -> Bool {
    if lhs.scalar != rhs.scalar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
